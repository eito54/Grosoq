<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grosoq スコアオーバーレイ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html,
        body {
            background: transparent !important;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        @font-face {
            font-family: 'MKWFont';
            src: url('/overlay/fonts/mk.ttf') format('truetype');
        }

        /* --- MKW Theme Styles --- */
        .mkw-parallelogram::before {
            content: '';
            position: absolute;
            /* 画像を少しだけ外側に広げて隙間を埋める */
            inset: -1px; 
            z-index: 0;
            background-image: url('/overlay/background.png');
            background-size: 100% 100%;
            background-position: center;
            background-repeat: no-repeat;
            border: 0;
            transform: skewX(-12deg);
            border-radius: 2px;
        }

        .mkw-parallelogram-active::before {
            inset: -1px;
            border: 0;
            box-shadow: none;
            background-clip: border-box;
            background-origin: border-box;
        }

        .theme-mkw #scores-container > div {
            gap: 2px !important; /* チームごとの隙間を最小限に */
        }

        .theme-mkw [data-team-row] {
            height: 32px !important; /* 行の高さを少し詰め、隙間を小さく見せる */
        }

        @keyframes currentPlayerPulseMKW {
            0%, 100% { 
                box-shadow: 0 0 10px 2px rgba(251, 191, 36, 0.6);
                border-color: #fbbf24;
            }
            50% { 
                box-shadow: 0 0 20px 4px rgba(251, 191, 36, 0.8);
                border-color: #fff;
            }
        }

        .mkw-font {
            font-family: 'MKWFont', sans-serif;
            text-shadow: none;
        }

        .mkw-score-text {
            font-family: 'MKWFont', sans-serif;
            text-shadow: none;
        }

        /* ----------------------- */

        .theme-mkw .mkw-added {
            color: #00ff00;
            text-shadow: 1px 1px 2px #000000;
        }

        /* ----------------------- */

        /* Next.jsのSortableListスタイルを完全再現 */

        /* 滑らかな虹色グラデーションアニメーション */
        @keyframes smoothRainbowBorder {
            0% {
                border-image: linear-gradient(90deg,
                        hsl(0, 100%, 50%), hsl(51, 100%, 50%), hsl(102, 100%, 50%),
                        hsl(153, 100%, 50%), hsl(204, 100%, 50%), hsl(255, 100%, 50%),
                        hsl(306, 100%, 50%), hsl(0, 100%, 50%)) 1;
            }

            25% {
                border-image: linear-gradient(90deg,
                        hsl(90, 100%, 50%), hsl(141, 100%, 50%), hsl(192, 100%, 50%),
                        hsl(243, 100%, 50%), hsl(294, 100%, 50%), hsl(345, 100%, 50%),
                        hsl(36, 100%, 50%), hsl(90, 100%, 50%)) 1;
            }

            50% {
                border-image: linear-gradient(90deg,
                        hsl(180, 100%, 50%), hsl(231, 100%, 50%), hsl(282, 100%, 50%),
                        hsl(333, 100%, 50%), hsl(24, 100%, 50%), hsl(75, 100%, 50%),
                        hsl(126, 100%, 50%), hsl(180, 100%, 50%)) 1;
            }

            75% {
                border-image: linear-gradient(90deg,
                        hsl(270, 100%, 50%), hsl(321, 100%, 50%), hsl(12, 100%, 50%),
                        hsl(63, 100%, 50%), hsl(114, 100%, 50%), hsl(165, 100%, 50%),
                        hsl(216, 100%, 50%), hsl(270, 100%, 50%)) 1;
            }

            100% {
                border-image: linear-gradient(90deg,
                        hsl(360, 100%, 50%), hsl(51, 100%, 50%), hsl(102, 100%, 50%),
                        hsl(153, 100%, 50%), hsl(204, 100%, 50%), hsl(255, 100%, 50%),
                        hsl(306, 100%, 50%), hsl(360, 100%, 50%)) 1;
            }
        }


        /* 躍動感のある加算得点アニメーション */
        @keyframes dynamicAddedScoreFloat {
            0% {
                opacity: 0;
                transform: translateY(15px) scale(0.7) rotateZ(5deg);
            }

            15% {
                opacity: 0.8;
                transform: translateY(-3px) scale(1.2) rotateZ(-2deg);
            }

            30% {
                opacity: 1;
                transform: translateY(0) scale(1) rotateZ(0deg);
            }

            70% {
                opacity: 1;
                transform: translateY(-2px) scale(1.05) rotateZ(0deg);
            }

            85% {
                opacity: 0.8;
                transform: translateY(-8px) scale(1.1) rotateZ(2deg);
            }

            100% {
                opacity: 0;
                transform: translateY(-20px) scale(0.8) rotateZ(-5deg);
            }
        }

        .added-score-float {
            animation: dynamicAddedScoreFloat 3.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            text-shadow: 0 0 8px var(--score-effect-color-rgba, rgba(34, 197, 94, 0.8));
        }

        /* カウントアップアニメーション中のスコア表示強調 */
        .score-counting-up {
            position: relative;
        }

        .score-counting-up::after {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 6px;
            background: linear-gradient(45deg, var(--score-effect-color, #22c55e), transparent, var(--score-effect-color, #22c55e));
            z-index: -1;
            opacity: 0.3;
            animation: countUpPulse 1s ease-in-out infinite alternate;
        }

        .theme-mkw .score-counting-up::after {
            display: none !important;
        }

        @keyframes countUpPulse {
            0% {
                opacity: 0.2;
                transform: scale(1);
            }

            100% {
                opacity: 0.4;
                transform: scale(1.02);
            }
        }

        /* スコア数値のカウントアップ中のフォント強調 */
        .counting-text {
            font-weight: 700;
            text-shadow: 0 0 4px rgba(34, 197, 94, 0.6);
            transition: all 0.1s ease;
        }

        .theme-mkw .counting-text {
            text-shadow: none !important;
        }

        @keyframes currentPlayerPulse {
            0% {
                box-shadow: 0 0 8px 2px rgba(251, 191, 36, 0.4);
                border-color: #fbbf24;
            }

            50% {
                box-shadow: 0 0 15px 4px #fbbf24;
                border-color: #fff;
            }

            100% {
                box-shadow: 0 0 8px 2px rgba(251, 191, 36, 0.4);
                border-color: #fbbf24;
            }
        }

        .animated-parallelogram-border::before {
            content: '';
            position: absolute;
            inset: -1.5px;
            z-index: 0;
            background: linear-gradient(to right, rgba(15, 23, 42, 0.95), rgba(30, 58, 138, 0.9));
            border-width: 2px;
            border-style: solid;
            border-color: #fbbf24;
            transform: skewX(-12deg);
            box-shadow: 0 1px 2px 0 rgba(251, 191, 36, 0.4), 0 1px 3px 0 rgba(251, 191, 36, 0.4);
            border-radius: 0.25rem;
            animation: currentPlayerPulse 2s infinite ease-in-out;
        }

        .static-parallelogram-border::before {
            content: '';
            position: absolute;
            inset: -1.5px;
            z-index: 0;
            background: linear-gradient(to right, rgba(15, 23, 42, 0.95), rgba(30, 58, 138, 0.9));
            border-width: 2px;
            border-style: solid;
            border-color: rgba(59, 130, 246, 0.7);
            transform: skewX(-12deg);
            box-shadow: 0 1px 2px 0 rgba(96, 165, 250, 0.4), 0 1px 3px 0 rgba(96, 165, 250, 0.4);
            border-radius: 0.25rem;
        }

        .rainbow-border::before {
            content: '';
            position: absolute;
            inset: -1.5px;
            z-index: 0;
            background: linear-gradient(to right, rgba(15, 23, 42, 0.95), rgba(30, 58, 138, 0.9));
            border-width: 2px;
            border-style: solid;
            transform: skewX(-12deg);
            border-radius: 0.25rem;
            animation: smoothRainbowBorder 4s linear infinite, currentPlayerPulse 2s infinite ease-in-out;
        }

        /* 動的な色による点滅エフェクト */
        @keyframes enhancedGreenFlash {
            0% {
                border-color: rgba(59, 130, 246, 0.7);
                box-shadow: 0 1px 2px 0 rgba(96, 165, 250, 0.4), 0 1px 3px 0 rgba(96, 165, 250, 0.4);
                background: linear-gradient(to right, rgba(15, 23, 42, 0.95), rgba(30, 58, 138, 0.9));
            }

            25% {
                border-color: rgba(34, 197, 94, 1);
                box-shadow: 0 0 15px 4px rgba(34, 197, 94, 0.9), 0 0 25px 8px rgba(34, 197, 94, 0.5);
                background: linear-gradient(to right, rgba(22, 101, 52, 0.95), rgba(34, 197, 94, 0.9));
            }

            50% {
                border-color: rgba(74, 222, 128, 1);
                box-shadow: 0 0 20px 6px rgba(74, 222, 128, 1), 0 0 35px 12px rgba(74, 222, 128, 0.6);
                background: linear-gradient(to right, rgba(22, 101, 52, 0.95), rgba(74, 222, 128, 0.9));
            }

            75% {
                border-color: rgba(34, 197, 94, 1);
                box-shadow: 0 0 15px 4px rgba(34, 197, 94, 0.9), 0 0 25px 8px rgba(34, 197, 94, 0.5);
                background: linear-gradient(to right, rgba(22, 101, 52, 0.95), rgba(34, 197, 94, 0.9));
            }

            100% {
                border-color: rgba(59, 130, 246, 0.7);
                box-shadow: 0 1px 2px 0 rgba(96, 165, 250, 0.4), 0 1px 3px 0 rgba(96, 165, 250, 0.4);
                background: linear-gradient(to right, rgba(15, 23, 42, 0.95), rgba(30, 58, 138, 0.9));
            }
        }

        .score-flash-active::before {
            animation: enhancedGreenFlash 0.6s cubic-bezier(0.4, 0, 0.6, 1) 2;
            animation-fill-mode: forwards;
            z-index: 5;
        }

        /* MKWテーマ用のフラッシュ（背景画像を維持） */
        .theme-mkw .score-flash-active::before {
            animation: mkw-score-flash 0.6s ease-in-out 2;
        }

        @keyframes mkw-score-flash {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.8) contrast(1.2); }
        }

        /* アニメーション終了後にクラスを削除するためのスタイル */
        .score-flash-active {
            animation-duration: 1.2s;
            /* 0.6s × 2回 */
            animation-fill-mode: forwards;
        }

        @keyframes fadeInOut {

            0%,
            100% {
                opacity: 0;
                transform: translateY(5px);
            }

            20%,
            80% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .added-score-indicator {
            animation: fadeInOut 2s ease-in-out forwards;
        }

        /* 躍動感のあるスライドインアニメーション */
        @keyframes dynamicSlideInFromRight {
            0% {
                opacity: 0;
                transform: translateX(40px) scale(0.8) rotateY(15deg);
            }

            50% {
                opacity: 0.8;
                transform: translateX(-5px) scale(1.05) rotateY(-3deg);
            }

            100% {
                opacity: 1;
                transform: translateX(0) scale(1) rotateY(0deg);
            }
        }

        .slide-in-initial {
            animation: dynamicSlideInFromRight 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        /* 躍動感のあるフェードイン/アウトアニメーション */
        @keyframes dynamicFadeInOverlay {
            0% {
                opacity: 0;
                transform: scale(0.85) rotateX(10deg);
            }

            50% {
                opacity: 0.7;
                transform: scale(1.05) rotateX(-2deg);
            }

            100% {
                opacity: 1;
                transform: scale(1) rotateX(0deg);
            }
        }

        @keyframes dynamicFadeOutOverlay {
            0% {
                opacity: 1;
                transform: scale(1) rotateX(0deg);
            }

            50% {
                opacity: 0.7;
                transform: scale(1.03) rotateX(5deg);
            }

            100% {
                opacity: 0;
                transform: scale(0.9) rotateX(-10deg);
            }
        }

        .overlay-fade-in {
            animation: dynamicFadeInOverlay 1.0s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            opacity: 1;
            transform: scale(1) rotateX(0deg);
        }

        .overlay-fade-out {
            animation: dynamicFadeOutOverlay 0.6s ease-in-out forwards;
            opacity: 0;
            transform: scale(0.9) rotateX(-10deg);
        }

        /* 滑らかな順位変動スライドアニメーション */
        @keyframes smoothSlideToPosition {
            0% {
                transform: translateY(var(--start-y, 0));
            }

            100% {
                transform: translateY(var(--end-y, 0));
            }
        }

        .position-slide {
            animation: smoothSlideToPosition 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        /* 順位変動中の要素を一時的に固定位置にする */
        .sliding-element {
            position: relative;
            z-index: 10;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        body {
            background: transparent;
            overflow: hidden;
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
        }

        #scores-container {
            opacity: 1;
            transform: scale(1);
            padding-left: 80px;
            /* 残りレース数表示のための余白 */
        }

        .no-data {
            color: #cccccc;
            text-align: center;
            font-style: italic;
            padding: 20px;
        }

        .static-parallelogram-border::before {
            content: '';
            position: absolute;
            inset: -1.5px;
            z-index: 0;
            background: linear-gradient(to right, rgba(15, 23, 42, 0.95), rgba(30, 58, 138, 0.9));
            border-width: 2px;
            border-style: solid;
            border-color: rgba(59, 130, 246, 0.7);
            transform: skewX(-12deg);
            box-shadow: 0 1px 2px 0 rgba(96, 165, 250, 0.4), 0 1px 3px 0 rgba(96, 165, 250, 0.4);
            border-radius: 0.25rem;
        }

        .animated-parallelogram-border::before {
            content: '';
            position: absolute;
            inset: -1.5px;
            z-index: 0;
            background: linear-gradient(to right, rgba(15, 23, 42, 0.95), rgba(30, 58, 138, 0.9));
            border-width: 2px;
            border-style: solid;
            border-color: #fbbf24;
            transform: skewX(-12deg);
            box-shadow: 0 1px 2px 0 rgba(251, 191, 36, 0.4), 0 1px 3px 0 rgba(251, 191, 36, 0.4);
            border-radius: 0.25rem;
            animation: currentPlayerPulse 2s infinite ease-in-out;
        }

        .rainbow-border::before {
            content: '';
            position: absolute;
            inset: -1.5px;
            z-index: 0;
            background: linear-gradient(to right, rgba(15, 23, 42, 0.95), rgba(30, 58, 138, 0.9));
            border-width: 2px;
            border-style: solid;
            transform: skewX(-12deg);
            border-radius: 0.25rem;
            animation: smoothRainbowBorder 4s linear infinite;
        }

        /* 非オーバーレイモード（テスト用） */
        body:not(.overlay-mode) {
            background: #1e293b;
            padding: 20px;
        }

        /* 残りレース数表示のアニメーション */
        @keyframes remainingRacesPulse {

            0%,
            100% {
                opacity: 0.8;
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4);
            }

            50% {
                opacity: 1;
                box-shadow: 0 0 0 4px rgba(59, 130, 246, 0);
            }
        }
    </style>
</head>

<body>
    <div class="w-full mx-auto mt-8 bg-transparent" id="scores-container">
        <div class="no-data">スコアデータがありません</div>
    </div>

    <script>
        // URLパラメータでオーバーレイモードかどうかを判定
        const urlParams = new URLSearchParams(window.location.search);
        const isOverlayMode = urlParams.get('overlay') === 'true';

        if (isOverlayMode) {
            document.body.classList.add('overlay-mode');
        }

        let currentTheme = null;

        function applyTheme(theme) {
            // bodyにテーマクラスを反映 (theme-default, theme-mkw など)
            document.body.classList.remove('theme-default', 'theme-mkw');
            document.body.classList.add('theme-' + theme);
            currentTheme = theme;
        }

        let selectedTeamInfo = null;
        let previousTeamOrder = []; // 前回のチーム順序を保存
        let hasDataEverLoaded = false; // データが一度でも読み込まれたかのフラグ
        let isUpdateBusy = false; // 更新処理中フラグ

        // チーム選択の切り替え
        function toggleTeamSelection(teamName) {
            if (selectedTeamInfo && selectedTeamInfo.name === teamName) {
                selectedTeamInfo = null;
            } else {
                selectedTeamInfo = { name: teamName };
            }
            updateScores(); // 即座に更新
        }

        let previousRemainingRaces = null;
        let lastShowRemainingRaces = true;

        // 残りレース数を更新する関数
        function updateRemainingRaces(remainingRaces, showRemainingRaces = true) {
            lastShowRemainingRaces = showRemainingRaces;
            const remainingRacesContainer = document.getElementById('remaining-races-container');

            // 設定で無効になっている場合は表示しない
            if (!showRemainingRaces || remainingRaces === undefined || remainingRaces === null) {
                if (remainingRacesContainer) {
                    remainingRacesContainer.style.display = 'none';
                }
                previousRemainingRaces = null;
                return;
            }

            if (remainingRacesContainer) {
                remainingRacesContainer.style.display = 'flex';

                const isMKW = currentTheme === 'mkw';
                const borderClass = isMKW ? 'mkw-parallelogram' : 'static-parallelogram-border';
                const fontClass = isMKW ? 'mkw-font' : '';

                // 残りレース数が0の場合は異なる表示
                if (remainingRaces === 0) {
                    remainingRacesContainer.innerHTML = `
                        <div class="relative ${borderClass} overflow-visible">
                            <div class="flex items-center gap-1 px-2 py-1 text-sm font-bold text-white relative z-10">
                                <svg class="h-3 w-3 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                </svg>
                                <span class="text-green-400 text-xs ${fontClass}">完了</span>
                            </div>
                        </div>
                    `;
                } else {
                    remainingRacesContainer.innerHTML = `
                        <div class="relative ${borderClass} overflow-visible">
                            <div class="flex items-center gap-1 px-2 py-1 text-sm font-bold text-white relative z-10">
                                <svg class="h-3 w-3 text-blue-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                </svg>
                                <span class="text-xs ${fontClass}">残り${remainingRaces}</span>
                            </div>
                        </div>
                    `;
                }
            }

            previousRemainingRaces = remainingRaces;
        }

        async function updateTheme() {
            try {
                const response = await fetch(`/api/config?t=${Date.now()}`);
                if (response.ok) {
                    const config = await response.json();
                    const newTheme = (config.overlayTheme || 'default').toLowerCase();
                    if (newTheme !== currentTheme) {
                        console.log(`Theme updated: ${currentTheme} -> ${newTheme}`);
                        applyTheme(newTheme);
                        // 再描画
                        updateScores();
                    }
                }
            } catch (error) {
                console.error('Failed to update theme:', error);
            }
        }

        // 初期設定
        updateTheme();

        // スコアデータを取得して表示
        async function updateScores() {
            if (isUpdateBusy) return;
            isUpdateBusy = true;

            try {
                console.log('Fetching scores...');
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);

                const response = await fetch('/api/scores', {
                    signal: controller.signal,
                    headers: { 'Content-Type': 'application/json' }
                });

                clearTimeout(timeoutId);
                if (!response.ok) throw new Error(`HTTP Error: ${response.status}`);

                const data = await response.json();
                const scores = Array.isArray(data.scores) ? data.scores : [];
                const remainingRaces = data.remainingRaces;
                const showRemainingRaces = data.showRemainingRaces !== false;

                // スコアでソート（降順）
                scores.sort((a, b) => (b.score || 0) - (a.score || 0));

                const container = document.getElementById('scores-container');

                if (scores.length === 0) {
                    container.innerHTML = '<div class="no-data">スコアデータがありません</div>';
                    // 残りレース数表示を隠す
                    const remainingRacesEl = document.getElementById('remaining-races-container');
                    if (remainingRacesEl) remainingRacesEl.style.display = 'none';
                    
                    previousScores.clear();
                    countUpAnimations.forEach(id => clearInterval(id));
                    countUpAnimations.clear();
                    hasDataEverLoaded = false;
                    previousTeamOrder = [];
                    return;
                }

                // チーム順序とステータス
                const currentTeamOrder = scores.map(team => team.team || team.name || '');
                const hasRankingChanged = hasDataEverLoaded && previousTeamOrder.length > 0 &&
                    !currentTeamOrder.every((team, index) => team === previousTeamOrder[index]);

                const needsCountUp = scores.some(team => {
                    const teamName = team.team || team.name || '';
                    const prevScore = previousScores.get(teamName);
                    return prevScore !== undefined && prevScore !== (team.score || 0);
                });

                // 自チームの自動選択
                const currentPlayerTeam = scores.find(team => team.isCurrentPlayer);
                if (currentPlayerTeam && (!selectedTeamInfo || selectedTeamInfo.name !== (currentPlayerTeam.team || currentPlayerTeam.name))) {
                    selectedTeamInfo = { name: (currentPlayerTeam.team || currentPlayerTeam.name) };
                }

                // レース数表示の更新
                updateRemainingRaces(remainingRaces, showRemainingRaces);
                previousRemainingRaces = remainingRaces;
                lastShowRemainingRaces = showRemainingRaces;

                // フェード効果（合計点計測時など）
                const shouldFadeIn = !hasDataEverLoaded || (data.isOverallUpdate === true);
                if (hasDataEverLoaded && shouldFadeIn) {
                    container.classList.add('overlay-fade-out');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    container.classList.remove('overlay-fade-out');
                }

                // --- 演出シーケンスの実行 ---
                if (hasRankingChanged) {
                    // 順位変動がある場合（並列アニメーション実行）
                    const preAnimationScores = new Map();
                    scores.forEach(team => {
                        const teamName = team.team || team.name || '';
                        const prevScore = previousScores.get(teamName);
                        if (prevScore !== undefined) preAnimationScores.set(teamName, prevScore);
                    });

                    // 演出開始前に状態を更新して後続の重複検知を防止
                    previousTeamOrder = [...currentTeamOrder];
                    
                    await animateRankingChange(currentTeamOrder, scores, container, preAnimationScores);
                } else if (needsCountUp) {
                    // 順位変動がないがスコアが加算された場合
                    renderScoreList(scores, container, true); // 前回の値で描画

                    const countUpPromises = [];
                    scores.forEach(team => {
                        const teamName = team.team || team.name || '';
                        const prevScore = previousScores.get(teamName);
                        const currentScore = team.score || 0;

                        if (prevScore !== undefined && prevScore !== currentScore) {
                            const scoreBox = document.querySelector(`[data-team="${escapeHtml(teamName)}"]`);
                            if (scoreBox) {
                                if (team.addedScore > 0) {
                                    scoreBox.classList.add('score-flash-active');
                                    setTimeout(() => scoreBox.classList.remove('score-flash-active'), 1200);
                                }
                                countUpPromises.push(animateCountUp(scoreBox, prevScore, currentScore, 1000));
                            }
                        }
                    });
                    await Promise.all(countUpPromises);
                    renderScoreList(scores, container, false); // 最終同期
                } else {
                    // 通常の定期更新
                    renderScoreList(scores, container, false);
                }

                // フェードイン完了
                if (shouldFadeIn) {
                    container.classList.add('overlay-fade-in');
                    setTimeout(() => container.classList.remove('overlay-fade-in'), 800);
                }

                // 状態更新
                previousTeamOrder = [...currentTeamOrder];
                scores.forEach(team => {
                    const teamName = team.team || team.name || '';
                    previousScores.set(teamName, team.score || 0);
                });
                hasDataEverLoaded = true;

                // 補助的な演出（加算点数フロートなど）
                // アニメーションが完了した後に実行されるようにする
                triggerAddedScoreEffects(scores);

                if (isFirstLoad) {
                    const teamRows = document.querySelectorAll('[data-team-row]');
                    teamRows.forEach((el, i) => {
                        el.classList.add('slide-in-initial');
                        el.style.animationDelay = `${i * 0.05}s`;
                    });
                    isFirstLoad = false;
                }

            } catch (error) {
                console.error('更新エラー:', error);
                const container = document.getElementById('scores-container');
                if (container) container.innerHTML = '<div class="no-data">スコア取得エラー</div>';
            } finally {
                isUpdateBusy = false;
            }
        }

        // 加算点数フロート演出の実行
        function triggerAddedScoreEffects(scores) {
            scores.forEach(team => {
                const teamName = team.team || team.name || '';
                if (team.addedScore && team.addedScore > 0) {
                    const addedScoreElement = document.querySelector(`[data-added-score="${escapeHtml(teamName)}"]`);
                    if (addedScoreElement && !addedScoreElement.classList.contains('added-score-float')) {
                        addedScoreElement.classList.add('added-score-float');
                        setTimeout(() => {
                            if (addedScoreElement) addedScoreElement.style.opacity = '0';
                        }, 3000);
                    }
                }
            });
        }

        // スコアリストをレンダリングする関数（カウントアップ対応版）
        function renderScoreList(scores, container, useCountUp = false) {
            const isMKW = currentTheme === 'mkw';

            container.innerHTML = `
                <div class="space-y-0 w-full max-w-md mx-auto relative ${isMKW ? 'theme-mkw' : ''}">
                    <!-- 残りレース数表示（1位チームの左側に独立配置） -->
                    <div id="remaining-races-container" class="absolute left-0 top-0 z-10" style="display: none; transform: translateX(-70px);">
                        <!-- 動的に内容が挿入される -->
                    </div>
                    
                    ${scores.map((team, index) => {
                const teamName = team.team || team.name || '';
                const isCurrentPlayer = team.isCurrentPlayer === true;
                const isFirstPlace = index === 0;
                const isTeamSelected = (selectedTeamInfo && selectedTeamInfo.name === teamName);
                const isEffectivelyCurrent = isCurrentPlayer || isTeamSelected;

                // ボーダークラスの決定
                let borderClass = isEffectivelyCurrent ? 'rainbow-border' : 'static-parallelogram-border';
                if (isMKW) {
                    borderClass = isEffectivelyCurrent ? 'mkw-parallelogram mkw-parallelogram-active' : 'mkw-parallelogram';
                }

                // 自チームを探す
                const myTeam = scores.find(s => s.isCurrentPlayer === true) ||
                    (selectedTeamInfo ? scores.find(s => (s.team || s.name) === selectedTeamInfo.name) : null);

                // カウントアップ値を決定
                let displayScore = team.score || 0;
                if (useCountUp && previousScores.has(teamName)) {
                    const prevScore = previousScores.get(teamName);
                    if (prevScore !== displayScore) {
                        displayScore = prevScore;
                    }
                }

                // 差分計算
                let diffDisplay = '';
                if (myTeam) {
                    if (teamName !== (myTeam.team || myTeam.name)) {
                        const scoreDiff = myTeam.score - team.score;
                        const diffText = scoreDiff === 0 ? "0" : scoreDiff > 0 ? `+${scoreDiff}` : `${scoreDiff}`;
                        const textColor = scoreDiff > 0 ? 'text-green-400' : scoreDiff < 0 ? 'text-red-400' : 'text-white';
                        const iconColor = scoreDiff > 0 ? 'text-green-400' : scoreDiff < 0 ? 'text-red-400' : 'text-blue-300';
                        diffDisplay = `
                                    <div class="relative ${borderClass} overflow-visible">
                                        <div class="flex items-center gap-1 px-1.5 py-0.5 text-sm font-bold ${textColor} relative z-10">
                                            <svg class="h-3 w-3 ${iconColor}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"/>
                                            </svg>
                                            <span class="${isMKW ? 'mkw-font' : ''}">${diffText}</span>
                                        </div>
                                    </div>
                                `;
                    }
                } else if (index < scores.length - 1) {
                    const scoreDiff = scores[index].score - scores[index + 1].score;
                    const diffText = scoreDiff > 0 ? `+${scoreDiff}` : `${scoreDiff}`;
                    diffDisplay = `
                                <div class="relative ${borderClass} overflow-visible">
                                    <div class="flex items-center gap-1 px-1.5 py-0.5 text-sm font-bold text-white relative z-10">
                                        <svg class="h-3 w-3 text-blue-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"/>
                                        </svg>
                                        <span class="${isMKW ? 'mkw-font' : ''}">${diffText}</span>
                                    </div>
                                </div>
                            `;
                }

                return `
                            <div class="${isMKW ? 'h-9' : 'h-12'} flex items-center gap-1 px-2 border-0 rounded-lg transition-all duration-200 cursor-pointer relative"
                                 ondblclick="toggleTeamSelection('${escapeHtml(teamName)}')"
                                 data-team-row="${escapeHtml(teamName)}">
                                
                                <!-- チーム名 -->
                                <div class="relative w-20 h-7 ${borderClass} overflow-visible">
                                    <div class="relative z-20 w-full h-full flex items-center justify-center">
                                        <span class="text-center ${isMKW && isEffectivelyCurrent ? 'font-bold text-yellow-400' : 'font-medium text-white'} whitespace-nowrap px-0.5" style="font-size: ${teamName.length <= 3 ? '0.75rem' : '0.6rem'}">
                                            ${escapeHtml(teamName)}
                                        </span>
                                    </div>
                                </div>
                                
                                <!-- スコアと差分表示のグループ -->
                                <div class="flex items-center gap-0.5">
                                    <!-- スコア -->
                                    <div class="relative w-16 h-7 score-box ${borderClass} overflow-visible" data-team="${escapeHtml(teamName)}">
                                        <div class="relative z-20 w-full h-full flex items-center justify-center">
                                            <span class="${isMKW ? 'mkw-score-text text-lg' : 'text-base font-medium'} text-center ${isMKW && isEffectivelyCurrent ? 'text-yellow-400' : 'text-white'}">
                                                ${displayScore}
                                            </span>
                                            <!-- 加算点数表示（スコア枠内の右側） -->
                                            ${team.addedScore && team.addedScore > 0 ? `
                                                <span class="absolute right-1 top-0 text-green-400 font-bold text-xs ${isMKW ? 'mkw-font' : ''}" data-added-score="${escapeHtml(teamName)}">
                                                    +${team.addedScore}
                                                </span>
                                            ` : ''}
                                        </div>
                                    </div>
                                    
                                    <!-- 差分スコア表示（スコア枠に隣接） -->
                                    ${diffDisplay}
                                </div>
                                
                                <!-- 右端のスペーサー -->
                                <div class="flex-1"></div>
                            </div>
                        `;
            }).join('')}
                </div>
            `;

            // 再描画時に残りレース数を復元
            updateRemainingRaces(previousRemainingRaces, lastShowRemainingRaces);
        }

        // 順位変動アニメーション（テーマに応じた演出順序制御）
        async function animateRankingChange(newOrder, scores, container, preAnimationScores = null) {
            const currentElements = container.querySelectorAll('[data-team-row]');
            if (currentElements.length === 0) {
                renderScoreList(scores, container, false);
                return;
            }

            const elementMap = new Map();
            const elementPositions = new Map();
            const isMKW = currentTheme === 'mkw';
            
            // 実際の要素の高さから計算
            const firstEl = currentElements[0].getBoundingClientRect();
            const secondEl = currentElements[1] ? currentElements[1].getBoundingClientRect() : null;
            const rowHeight = secondEl ? (secondEl.top - firstEl.top) : firstEl.height;

            currentElements.forEach((element, index) => {
                const teamName = element.getAttribute('data-team-row');
                elementMap.set(teamName, element);
                elementPositions.set(teamName, index * rowHeight);
            });

            const newPositions = new Map();
            newOrder.forEach((teamName, index) => {
                newPositions.set(teamName, index * rowHeight);
            });

            // 1. スライドアニメーションの準備
            const slidePromises = [];
            elementMap.forEach((element, teamName) => {
                const currentPos = elementPositions.get(teamName);
                const newPos = newPositions.get(teamName);

                if (currentPos !== undefined && newPos !== undefined && Math.abs(currentPos - newPos) > 1) {
                    const deltaY = newPos - currentPos;
                    element.style.setProperty('--start-y', '0px');
                    element.style.setProperty('--end-y', `${deltaY}px`);
                    element.classList.add('position-slide', 'sliding-element');

                    slidePromises.push(new Promise(resolve => {
                        element.addEventListener('animationend', () => {
                            element.style.transform = `translateY(${deltaY}px)`;
                            element.classList.remove('position-slide');
                            resolve();
                        }, { once: true });
                    }));
                }
            });

            const countUpAnimations = [];
            const triggerCountUp = () => {
                if (!preAnimationScores) return;
                scores.forEach(team => {
                    const teamName = team.team || team.name || '';
                    const prevScore = preAnimationScores.get(teamName);
                    const currentScore = team.score || 0;
                    
                    if (prevScore !== undefined && prevScore !== currentScore) {
                        const rowElement = elementMap.get(teamName);
                        if (rowElement) {
                            const scoreBox = rowElement.querySelector(`[data-team="${escapeHtml(teamName)}"]`);
                            if (scoreBox) {
                                if (team.addedScore > 0) {
                                    // フラッシュエフェクト（背景の発光）は、スライドと同時だと目立ちすぎるため
                                    // あえて少しだけ遅らせて開始します（カウントアップ自体は即座に並列で走ります）
                                    setTimeout(() => {
                                        if (scoreBox) scoreBox.classList.add('score-flash-active');
                                    }, 150);
                                    setTimeout(() => {
                                        if (scoreBox) scoreBox.classList.remove('score-flash-active');
                                    }, 1350);
                                }
                                countUpAnimations.push(animateCountUp(scoreBox, prevScore, currentScore, 1000));
                            }
                        }
                    }
                });
            };

            // 2. 演出シーケンスの実行
            // 順位変動のスライドと点数のカウントアップを並列で実行
            triggerCountUp();
            await Promise.all([...slidePromises, ...countUpAnimations]);

            // 3. 最終的なDOM構造に並べ替えて再描画
            renderScoreList(scores, container, false);
            
            elementMap.forEach((element) => {
                element.style.removeProperty('transform');
                element.classList.remove('sliding-element');
            });
        }

        // HTMLエスケープ関数
        function escapeHtml(text) {
            if (text === undefined || text === null) return '';
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return String(text).replace(/[&<>"']/g, function (m) { return map[m]; });
        }

        let previousScores = new Map(); // 前回のスコアを保存
        let isFirstLoad = true; // 初回読み込みフラグ
        let countUpAnimations = new Map(); // 進行中のカウントアップアニメーションを管理

        // カウントアップアニメーション関数
        function animateCountUp(element, startValue, endValue, duration = 1000) {
            return new Promise((resolve) => {
                const teamName = element.getAttribute('data-team');

                // 既存のアニメーションがあれば停止
                if (countUpAnimations.has(teamName)) {
                    clearInterval(countUpAnimations.get(teamName));
                }

                const startTime = Date.now();
                const difference = endValue - startValue;

                // スコア要素内のテキスト要素を取得
                const isMKW = currentTheme === 'mkw';
                const scoreTextElement = element.querySelector('span');

                if (!scoreTextElement) {
                    resolve();
                    return;
                }

                // カウントアップ中の視覚効果を追加
                element.classList.add('score-counting-up');
                scoreTextElement.classList.add('counting-text');

                const updateScore = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // イージング関数（accelerated deceleration）
                    const easeOutQuad = 1 - Math.pow(1 - progress, 2);
                    const currentValue = Math.floor(startValue + (difference * easeOutQuad));

                    // スコア要素内のテキストを更新
                    scoreTextElement.textContent = currentValue;

                    if (progress >= 1) {
                        // アニメーション完了
                        scoreTextElement.textContent = endValue;

                        // 視覚効果を削除
                        element.classList.remove('score-counting-up');
                        scoreTextElement.classList.remove('counting-text');

                        countUpAnimations.delete(teamName);
                        console.log(`Count-up animation completed for ${teamName}: ${startValue} → ${endValue}`);
                        resolve();
                    }
                };

                // アニメーションを開始
                const intervalId = setInterval(updateScore, 16); // 約60fps
                countUpAnimations.set(teamName, intervalId);

                // 完了時の処理（フェイルセーフ）
                setTimeout(() => {
                    clearInterval(intervalId);
                    countUpAnimations.delete(teamName);

                    // 最終値を設定
                    scoreTextElement.textContent = endValue;

                    // 視覚効果を削除
                    element.classList.remove('score-counting-up');
                    scoreTextElement.classList.remove('counting-text');

                    resolve();
                }, duration + 100); // 少し余裕を持たせる
            });
        }

        // 初回読み込み
        updateScores();

        // SSE接続でリアルタイム更新（堅牢性強化版）
        let sseReconnectAttempts = 0;
        const MAX_SSE_RECONNECT_ATTEMPTS = 10;
        const BASE_RECONNECT_DELAY = 1000; // 1秒
        let currentEventSource = null;

        function setupSSE() {
            // 既存の接続をクリーンアップ
            if (currentEventSource) {
                currentEventSource.close();
                currentEventSource = null;
            }

            console.log(`SSE接続試行 (${sseReconnectAttempts + 1}/${MAX_SSE_RECONNECT_ATTEMPTS})`);

            try {
                currentEventSource = new EventSource('/api/scores/events');

                currentEventSource.onopen = function (event) {
                    console.log('SSE接続が正常に確立されました');
                    sseReconnectAttempts = 0; // 成功時はカウンターをリセット
                    // 再接続時に最新状態へ同期
                    updateScores();
                };

                currentEventSource.onmessage = function (event) {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'scores-updated') {
                            console.log('Received score update notification');
                            updateScores();
                        } else if (data.type === 'config-updated') {
                            console.log('Received config update notification');
                            updateTheme();
                        } else if (data.type === 'connected') {
                            console.log('SSE接続確認');
                        }
                    } catch (error) {
                        console.error('SSE message parsing error:', error);
                    }
                };

                currentEventSource.onerror = function (error) {
                    console.error('SSE connection error:', error);

                    // 現在の接続を閉じる
                    if (currentEventSource) {
                        currentEventSource.close();
                        currentEventSource = null;
                    }

                    // 最大再試行回数に達した場合は停止
                    if (sseReconnectAttempts >= MAX_SSE_RECONNECT_ATTEMPTS) {
                        console.error('SSE再接続の最大試行回数に達しました。手動でページを更新してください。');
                        return;
                    }

                    // 指数バックオフで再接続を試行
                    const delay = BASE_RECONNECT_DELAY * Math.pow(2, sseReconnectAttempts);
                    const maxDelay = 30000; // 最大30秒
                    const actualDelay = Math.min(delay, maxDelay);

                    console.log(`${actualDelay / 1000}秒後にSSE再接続を試行します...`);
                    sseReconnectAttempts++;

                    setTimeout(() => {
                        setupSSE();
                    }, actualDelay);
                };

            } catch (error) {
                console.error('SSE接続の初期化に失敗:', error);

                // 初期化エラーの場合も再試行
                if (sseReconnectAttempts < MAX_SSE_RECONNECT_ATTEMPTS) {
                    sseReconnectAttempts++;
                    setTimeout(() => {
                        setupSSE();
                    }, BASE_RECONNECT_DELAY);
                }
            }
        }

        // ページがアンロードされる前にSSE接続をクリーンアップ
        window.addEventListener('beforeunload', function () {
            if (currentEventSource) {
                currentEventSource.close();
                currentEventSource = null;
            }
        });

        // SSE接続を開始
        setupSSE();
    </script>
</body>

</html>