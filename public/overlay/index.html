<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grosoq スコアオーバーレイ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html,
        body {
            background: transparent !important;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        @font-face {
            font-family: 'MKWFont';
            src: url('/overlay/fonts/mk.ttf') format('truetype');
        }

        /* --- MKW Theme Styles --- */
        .mkw-parallelogram::before {
            content: '';
            position: absolute;
            /* 画像を少しだけ外側に広げて隙間を埋める */
            inset: -1px;
            z-index: 0;
            background-image: url('/overlay/background.png');
            background-size: 100% 100%;
            background-position: center;
            background-repeat: no-repeat;
            border: 0;
            transform: skewX(-12deg);
            border-radius: 2px;
        }

        .mkw-parallelogram-active::before {
            inset: -1px;
            border: 0;
            box-shadow: none;
            background-clip: border-box;
            background-origin: border-box;
        }

        .theme-mkw #scores-container>div {
            gap: 2px !important;
            /* チームごとの隙間を最小限に */
        }

        .theme-mkw [data-team-row] {
            height: 32px !important;
            /* 行の高さを少し詰め、隙間を小さく見せる */
        }

        @keyframes currentPlayerPulseMKW {

            0%,
            100% {
                box-shadow: 0 0 10px 2px rgba(251, 191, 36, 0.6);
                border-color: #fbbf24;
            }

            50% {
                box-shadow: 0 0 20px 4px rgba(251, 191, 36, 0.8);
                border-color: #fff;
            }
        }

        .mkw-font {
            font-family: 'MKWFont', sans-serif;
            text-shadow: none;
        }

        .mkw-score-text {
            font-family: 'MKWFont', sans-serif;
            text-shadow: none;
        }

        /* ----------------------- */

        .theme-mkw .mkw-added {
            color: #00ff00;
            text-shadow: 1px 1px 2px #000000;
        }

        /* ----------------------- */

        /* Next.jsのSortableListスタイルを完全再現 */

        /* 滑らかなグラデーション移動アニメーション */
        @keyframes flowGradient {
            0% {
                background-position: 0% 0%, 0% 0%;
            }

            100% {
                background-position: 0% 0%, 100% 0%;
            }
        }

        /* 躍動感のある加算得点アニメーション */
        @keyframes dynamicAddedScoreFloat {
            0% {
                opacity: 0;
                transform: translateY(15px) scale(0.7) rotateZ(5deg);
            }

            15% {
                opacity: 0.8;
                transform: translateY(-3px) scale(1.2) rotateZ(-2deg);
            }

            30% {
                opacity: 1;
                transform: translateY(0) scale(1) rotateZ(0deg);
            }

            70% {
                opacity: 1;
                transform: translateY(-2px) scale(1.05) rotateZ(0deg);
            }

            85% {
                opacity: 0.8;
                transform: translateY(-8px) scale(1.1) rotateZ(2deg);
            }

            100% {
                opacity: 0;
                transform: translateY(-20px) scale(0.8) rotateZ(-5deg);
            }
        }

        .added-score-float {
            animation: dynamicAddedScoreFloat calc(3.5s * var(--anim-factor)) cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            text-shadow: 0 0 8px var(--score-effect-color-rgba, rgba(34, 197, 94, 0.8));
            will-change: transform, opacity;
        }

        [data-added-score] {
            opacity: 0;
        }

        /* カウントアップアニメーション中のスコア表示強調 */
        .score-counting-up {
            position: relative;
        }

        .score-counting-up::after {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 6px;
            background: linear-gradient(45deg, var(--score-effect-color, #22c55e), transparent, var(--score-effect-color, #22c55e));
            z-index: -1;
            opacity: 0.3;
            animation: countUpPulse calc(1s * var(--anim-factor)) ease-in-out infinite alternate;
        }

        .theme-mkw .score-counting-up::after {
            display: none !important;
        }

        @keyframes countUpPulse {
            0% {
                opacity: 0.2;
                transform: scale(1);
            }

            100% {
                opacity: 0.4;
                transform: scale(1.02);
            }
        }

        /* スコア数値のカウントアップ中のフォント強調 */
        .counting-text {
            font-weight: 700;
            text-shadow: 0 0 4px var(--score-effect-color-rgba, rgba(34, 197, 94, 0.6));
            transition: all 0.1s ease;
        }

        .theme-mkw .counting-text {
            text-shadow: none !important;
        }

        @keyframes currentPlayerPulse {
            0% {
                box-shadow: 0 0 8px 2px var(--own-team-color-rgba, rgba(251, 191, 36, 0.4));
            }

            50% {
                box-shadow: 0 0 15px 4px var(--own-team-color, #fbbf24);
            }

            100% {
                box-shadow: 0 0 8px 2px var(--own-team-color-rgba, rgba(251, 191, 36, 0.4));
            }
        }

        .animated-parallelogram-border::before {
            content: '';
            position: absolute;
            inset: -1.5px;
            z-index: 0;
            background: linear-gradient(to right, rgba(15, 23, 42, 0.95), rgba(30, 58, 138, 0.9));
            border-width: 2px;
            border-style: solid;
            border-color: var(--own-team-color, #fbbf24);
            transform: skewX(-12deg);
            border-radius: 0.25rem;
        }

        .static-parallelogram-border::before {
            content: '';
            position: absolute;
            inset: -1.5px;
            z-index: 0;
            background: linear-gradient(to right, rgba(15, 23, 42, 0.95), rgba(30, 58, 138, 0.9));
            border-width: 2px;
            border-style: solid;
            border-color: rgba(59, 130, 246, 0.7);
            transform: skewX(-12deg);
            box-shadow: 0 1px 2px 0 rgba(96, 165, 250, 0.4), 0 1px 3px 0 rgba(96, 165, 250, 0.4);
            border-radius: 0.25rem;
        }

        .rainbow-border::before {
            content: '';
            position: absolute;
            inset: -1.5px;
            z-index: 0;
            border: 2px solid transparent;
            transform: skewX(-12deg);
            border-radius: 0.5rem;
            background: linear-gradient(to right, rgba(15, 23, 42, 0.95), rgba(30, 58, 138, 0.9)) padding-box,
                linear-gradient(to right,
                    hsl(0, 100%, 50%) 0%,
                    hsl(60, 100%, 50%) 8.33%,
                    hsl(120, 100%, 50%) 16.66%,
                    hsl(180, 100%, 50%) 25%,
                    hsl(240, 100%, 50%) 33.33%,
                    hsl(300, 100%, 50%) 41.66%,
                    hsl(360, 100%, 50%) 50%,
                    hsl(60, 100%, 50%) 58.33%,
                    hsl(120, 100%, 50%) 66.66%,
                    hsl(180, 100%, 50%) 75%,
                    hsl(240, 100%, 50%) 83.33%,
                    hsl(300, 100%, 50%) 91.66%,
                    hsl(360, 100%, 50%) 100%) border-box;
            background-size: 100% 100%, 200% 100%;
            background-clip: padding-box, border-box;
            background-origin: padding-box, border-box;
            animation: flowGradient 3s linear infinite;
        }

        /* グラデーションバリエーション (高速かつ滑らかな描画に改善) */
        .gradient-blue-border::before {
            background: linear-gradient(to right, rgba(15, 23, 42, 0.95), rgba(30, 58, 138, 0.9)) padding-box,
                linear-gradient(to right, #1d4ed8, #22d3ee, #1d4ed8, #22d3ee, #1d4ed8) border-box;
            background-size: 100% 100%, 200% 100%;
            animation: flowGradient 3s linear infinite !important;
        }

        .gradient-pink-border::before {
            background: linear-gradient(to right, rgba(15, 23, 42, 0.95), rgba(30, 58, 138, 0.9)) padding-box,
                linear-gradient(to right, #be123c, #c084fc, #be123c, #c084fc, #be123c) border-box;
            background-size: 100% 100%, 200% 100%;
            animation: flowGradient 3s linear infinite !important;
        }

        .gradient-orange-border::before {
            background: linear-gradient(to right, rgba(15, 23, 42, 0.95), rgba(30, 58, 138, 0.9)) padding-box,
                linear-gradient(to right, #c2410c, #fde047, #c2410c, #fde047, #c2410c) border-box;
            background-size: 100% 100%, 200% 100%;
            animation: flowGradient 3s linear infinite !important;
        }

        .gradient-emerald-border::before {
            background: linear-gradient(to right, rgba(15, 23, 42, 0.95), rgba(30, 58, 138, 0.9)) padding-box,
                linear-gradient(to right, #15803d, #22d3ee, #15803d, #22d3ee, #15803d) border-box;
            background-size: 100% 100%, 200% 100%;
            animation: flowGradient 3s linear infinite !important;
        }

        .gradient-blue-border::before,
        .gradient-pink-border::before,
        .gradient-orange-border::before,
        .gradient-emerald-border::before {
            content: '';
            position: absolute;
            inset: -1.5px;
            z-index: 0;
            border: 2px solid transparent;
            transform: skewX(-12deg);
            border-radius: 0.5rem;
            /* rounded-lg と一致 */
            background-clip: padding-box, border-box;
            background-origin: padding-box, border-box;
        }

        /* 動的な色による点滅エフェクト */
        @keyframes enhancedGreenFlash {
            0% {
                border-color: rgba(59, 130, 246, 0.7);
                box-shadow: 0 1px 2px 0 rgba(96, 165, 250, 0.4), 0 1px 3px 0 rgba(96, 165, 250, 0.4);
                background: linear-gradient(to right, rgba(15, 23, 42, 0.95), rgba(30, 58, 138, 0.9));
                border-radius: 0.25rem;
            }

            25% {
                border-color: var(--score-effect-color, #22c55e);
                box-shadow: 0 0 15px 4px var(--score-effect-color-rgba, rgba(34, 197, 94, 0.9)), 0 0 25px 8px var(--score-effect-color-rgba, rgba(34, 197, 94, 0.5));
                background: linear-gradient(to right, rgba(22, 101, 52, 0.95), var(--score-effect-color-rgba, rgba(34, 197, 94, 0.9)));
                border-radius: 0.25rem;
            }

            50% {
                border-color: var(--score-effect-color, #22c55e);
                box-shadow: 0 0 20px 6px var(--score-effect-color, #22c55e), 0 0 35px 12px var(--score-effect-color-rgba, rgba(74, 222, 128, 0.6));
                background: linear-gradient(to right, rgba(22, 101, 52, 0.95), var(--score-effect-color-rgba, rgba(74, 222, 128, 0.9)));
                border-radius: 0.25rem;
            }

            75% {
                border-color: var(--score-effect-color, #22c55e);
                box-shadow: 0 0 15px 4px var(--score-effect-color-rgba, rgba(34, 197, 94, 0.9)), 0 0 25px 8px var(--score-effect-color-rgba, rgba(34, 197, 94, 0.5));
                background: linear-gradient(to right, rgba(22, 101, 52, 0.95), var(--score-effect-color-rgba, rgba(34, 197, 94, 0.9)));
                border-radius: 0.25rem;
            }

            100% {
                border-color: rgba(59, 130, 246, 0.7);
                box-shadow: 0 1px 2px 0 rgba(96, 165, 250, 0.4);
                background: linear-gradient(to right, rgba(15, 23, 42, 0.95), rgba(30, 58, 138, 0.9));
                border-radius: 0.25rem;
            }
        }

        .score-flash-active::before {
            animation: enhancedGreenFlash calc(0.6s * var(--anim-factor)) cubic-bezier(0.4, 0, 0.6, 1) 2;
            animation-fill-mode: forwards;
            z-index: 5;
        }

        /* MKWテーマ用のフラッシュ（背景画像を維持） */
        .theme-mkw .score-flash-active::before {
            animation: mkw-score-flash calc(0.6s * var(--anim-factor)) ease-in-out 2;
        }

        @keyframes mkw-score-flash {

            0%,
            100% {
                filter: brightness(1);
            }

            50% {
                filter: brightness(1.8) contrast(1.2);
            }
        }

        /* アニメーション終了後にクラスを削除するためのスタイル */
        .score-flash-active {
            animation-duration: calc(1.2s * var(--anim-factor));
            /* 0.6s × 2回 */
            animation-fill-mode: forwards;
        }

        @keyframes fadeInOut {

            0%,
            100% {
                opacity: 0;
                transform: translateY(5px);
            }

            20%,
            80% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .added-score-indicator {
            animation: fadeInOut 2s ease-in-out forwards;
        }

        /* 躍動感のあるスライドインアニメーション */
        @keyframes dynamicSlideInFromRight {
            0% {
                opacity: 0;
                transform: translateX(40px) scale(0.8) rotateY(15deg);
            }

            50% {
                opacity: 0.8;
                transform: translateX(-5px) scale(1.05) rotateY(-3deg);
            }

            100% {
                opacity: 1;
                transform: translateX(0) scale(1) rotateY(0deg);
            }
        }

        .slide-in-initial {
            animation: dynamicSlideInFromRight calc(0.6s * var(--anim-factor)) cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        /* 躍動感のあるフェードイン/アウトアニメーション */
        @keyframes dynamicFadeInOverlay {
            0% {
                opacity: 0;
                transform: scale(0.85) rotateX(10deg);
            }

            50% {
                opacity: 0.7;
                transform: scale(1.05) rotateX(-2deg);
            }

            100% {
                opacity: 1;
                transform: scale(1) rotateX(0deg);
            }
        }

        @keyframes dynamicFadeOutOverlay {
            0% {
                opacity: 1;
                transform: scale(1) rotateX(0deg);
            }

            50% {
                opacity: 0.7;
                transform: scale(1.03) rotateX(5deg);
            }

            100% {
                opacity: 0;
                transform: scale(0.9) rotateX(-10deg);
            }
        }

        .overlay-fade-in {
            animation: dynamicFadeInOverlay calc(1.0s * var(--anim-factor)) cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            opacity: 1;
            transform: translateZ(0) scale(1) rotateX(0deg);
            will-change: transform, opacity;
        }

        .overlay-fade-out {
            animation: dynamicFadeOutOverlay calc(0.6s * var(--anim-factor)) ease-in-out forwards;
            opacity: 0;
            transform: translateZ(0) scale(0.9) rotateX(-10deg);
            will-change: transform, opacity;
        }

        /* 滑らかな順位変動スライドアニメーション */
        @keyframes smoothSlideToPosition {
            0% {
                transform: translateY(var(--start-y, 0)) translateZ(0);
            }

            100% {
                transform: translateY(var(--end-y, 0)) translateZ(0);
            }
        }

        .position-slide {
            animation: smoothSlideToPosition calc(0.6s * var(--anim-factor)) cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            will-change: transform;
        }

        /* 順位変動中の要素を一時的に固定位置にする */
        .sliding-element {
            position: relative;
            z-index: 10;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            will-change: transform;
        }

        body {
            background: transparent;
            overflow: hidden;
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
        }

        #scores-container {
            opacity: 1;
            transform: scale(1);
            padding-left: 80px;
            /* 残りレース数表示のための余白 */
        }

        .no-data {
            color: #cccccc;
            text-align: center;
            font-style: italic;
            padding: 20px;
        }

        /* 非オーバーレイモード（テスト用） */
        body:not(.overlay-mode) {
            background: #1e293b;
            padding: 20px;
        }

        /* 残りレース数表示のアニメーション */
        @keyframes remainingRacesPulse {

            0%,
            100% {
                opacity: 0.8;
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4);
            }

            50% {
                opacity: 1;
                box-shadow: 0 0 0 4px rgba(59, 130, 246, 0);
            }
        }


        :root {
            --anim-factor: 1;
        }
    </style>
</head>

<body>
    <div class="w-full mx-auto mt-8 bg-transparent" id="scores-container">
        <div class="no-data">スコアデータがありません</div>
    </div>

    <script>
        // URLパラメータでオーバーレイモードかどうかを判定
        const urlParams = new URLSearchParams(window.location.search);
        const isOverlayMode = urlParams.get('overlay') === 'true';

        const isPreviewMode = urlParams.get('preview') === 'true';

        if (isOverlayMode) {
            document.body.classList.add('overlay-mode');
            if (isPreviewMode) {
                document.body.classList.add('preview-mode');
                // Scale content to fit if needed, handled by CSS or iframe scaling
            }
        }

        let currentTheme = null;

        function applyTheme(theme) {
            // bodyにテーマクラスを反映 (theme-default, theme-mkw など)
            document.body.classList.remove('theme-default', 'theme-mkw');
            document.body.classList.add('theme-' + theme);
            currentTheme = theme;
        }

        let selectedTeamInfo = null;
        let previousTeamOrder = []; // 前回のチーム順序を保存
        let hasDataEverLoaded = false; // データが一度でも読み込まれたかのフラグ
        let isUpdateBusy = false; // 更新処理中フラグ

        // チーム選択の切り替え
        function toggleTeamSelection(teamName) {
            if (selectedTeamInfo && selectedTeamInfo.name === teamName) {
                selectedTeamInfo = null;
            } else {
                selectedTeamInfo = { name: teamName };
            }
            updateScores(); // 即座に更新
        }

        let previousRemainingRaces = null;
        let lastShowRemainingRaces = true;
        let lastAnimatedTotalScores = new Map(); // 加算点アニメーション済みの合計点を記録

        // 残りレース数を更新する関数
        function updateRemainingRaces(remainingRaces, showRemainingRaces = true) {
            lastShowRemainingRaces = showRemainingRaces;
            const remainingRacesContainer = document.getElementById('remaining-races-container');

            // 設定で無効になっている場合は表示しない
            if (!showRemainingRaces || remainingRaces === undefined || remainingRaces === null) {
                if (remainingRacesContainer) {
                    remainingRacesContainer.style.display = 'none';
                }
                previousRemainingRaces = null;
                return;
            }

            if (remainingRacesContainer) {
                remainingRacesContainer.style.display = 'flex';

                const isMKW = currentTheme === 'mkw';
                const borderClass = isMKW ? 'mkw-parallelogram' : 'static-parallelogram-border';
                const fontClass = isMKW ? 'mkw-font' : '';

                // 残りレース数が0の場合は異なる表示
                if (remainingRaces === 0) {
                    remainingRacesContainer.innerHTML = `
                        <div class="relative ${borderClass} overflow-visible">
                            <div class="flex items-center gap-1 px-2 py-1 text-sm font-bold text-white relative z-10">
                                <svg class="h-3 w-3 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                </svg>
                                <span class="text-green-400 text-xs ${fontClass}">完了</span>
                            </div>
                        </div>
                    `;
                } else {
                    remainingRacesContainer.innerHTML = `
                        <div class="relative ${borderClass} overflow-visible">
                            <div class="flex items-center gap-1 px-2 py-1 text-sm font-bold text-white relative z-10">
                                <svg class="h-3 w-3 text-blue-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                </svg>
                                <span class="text-xs ${fontClass}">残り${remainingRaces}</span>
                            </div>
                        </div>
                    `;
                }
            }

            previousRemainingRaces = remainingRaces;
        }

        async function updateTheme() {
            try {
                const response = await fetch(`/api/config?t=${Date.now()}`);
                if (response.ok) {
                    const config = await response.json();

                    // テーマの適用
                    const newTheme = (config.overlayTheme || 'default').toLowerCase();
                    if (newTheme !== currentTheme) {
                        console.log(`Theme updated: ${currentTheme} -> ${newTheme}`);
                        applyTheme(newTheme);
                    }

                    // カラー設定の適用 (CSS変数)
                    if (config.overlayColors) {
                        const root = document.documentElement;
                        const colors = config.overlayColors;

                        // エフェクト色
                        if (colors.scoreEffect) {
                            root.style.setProperty('--score-effect-color', colors.scoreEffect);
                            // RGBA版も生成
                            const r = parseInt(colors.scoreEffect.slice(1, 3), 16);
                            const g = parseInt(colors.scoreEffect.slice(3, 5), 16);
                            const b = parseInt(colors.scoreEffect.slice(5, 7), 16);
                            root.style.setProperty('--score-effect-color-rgba', `rgba(${r}, ${g}, ${b}, 0.8)`);
                        }

                        // 自チーム色
                        if (colors.ownTeamColor) {
                            root.style.setProperty('--own-team-color', colors.ownTeamColor);
                            const r = parseInt(colors.ownTeamColor.slice(1, 3), 16);
                            const g = parseInt(colors.ownTeamColor.slice(3, 5), 16);
                            const b = parseInt(colors.ownTeamColor.slice(5, 7), 16);
                            root.style.setProperty('--own-team-color-rgba', `rgba(${r}, ${g}, ${b}, 0.4)`);
                        }

                        // Animation settings
                        if (config.overlayAnimations) {
                            const { speed, rankAnim, flash } = config.overlayAnimations;
                            // Check if speed has changed to avoid redundant style recalculations
                            if (window.animSettings?.speed !== speed) {
                                document.documentElement.style.setProperty('--anim-factor', `${1 / (speed || 1)}`);
                            }
                            window.animSettings = { rankAnim, flash, speed };
                        } else {
                            window.animSettings = { rankAnim: true, flash: true, speed: 1.0 };
                            document.documentElement.style.setProperty('--anim-factor', '1');
                        }

                        // スタイル情報をグローバルに保持（レンダリング時に使用）
                        window.overlayConfig = config;
                    }

                    updateScores();
                }
            } catch (error) {
                console.error('Failed to update theme/colors:', error);
            }
        }

        // 初期設定
        if (!isPreviewMode) {
            updateTheme();
            setInterval(updateTheme, 3000); // 3秒ごとに設定（色やスタイル）をチェック
        } else {
            // Preview Mode: Listen for messages from parent
            window.addEventListener('message', (event) => {
                const data = event.data;
                if (!data) return;

                if (data.type === 'updateConfig' && data.config) {
                    const config = data.config;
                    // Apply theme
                    const newTheme = (config.overlayTheme || 'default').toLowerCase();
                    if (newTheme !== currentTheme) applyTheme(newTheme);

                    // Apply colors
                    if (config.overlayColors) {
                        const root = document.documentElement;
                        const colors = config.overlayColors;
                        if (colors.scoreEffect) {
                            root.style.setProperty('--score-effect-color', colors.scoreEffect);
                            const r = parseInt(colors.scoreEffect.slice(1, 3), 16);
                            const g = parseInt(colors.scoreEffect.slice(3, 5), 16);
                            const b = parseInt(colors.scoreEffect.slice(5, 7), 16);
                            root.style.setProperty('--score-effect-color-rgba', `rgba(${r}, ${g}, ${b}, 0.8)`);
                        }
                        if (colors.ownTeamColor) {
                            root.style.setProperty('--own-team-color', colors.ownTeamColor);
                            const r = parseInt(colors.ownTeamColor.slice(1, 3), 16);
                            const g = parseInt(colors.ownTeamColor.slice(3, 5), 16);
                            const b = parseInt(colors.ownTeamColor.slice(5, 7), 16);
                            root.style.setProperty('--own-team-color-rgba', `rgba(${r}, ${g}, ${b}, 0.4)`);
                        }
                        if (config.overlayAnimations) {
                            const { speed, rankAnim, flash } = config.overlayAnimations;
                            if (window.animSettings?.speed !== speed) {
                                document.documentElement.style.setProperty('--anim-factor', `${1 / (speed || 1)}`);
                            }
                            window.animSettings = { rankAnim, flash, speed };
                        } else {
                            window.animSettings = { rankAnim: true, flash: true, speed: 1.0 };
                            document.documentElement.style.setProperty('--anim-factor', '1');
                        }
                        window.overlayConfig = config;
                    }
                } else if (data.type === 'updateScores' && data.scores) {
                    // Force process using the shared logic to enable animations
                    processScoreData(data.scores);
                }
            });
            // Request initial config
            window.parent.postMessage({ type: 'overlayReady' }, '*');
        }

        // スコアデータを取得して表示
        async function updateScores() {
            if (isUpdateBusy) return;
            isUpdateBusy = true;

            try {
                console.log('Fetching scores...');
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);

                const response = await fetch(`/api/scores?t=${Date.now()}`, {
                    signal: controller.signal,
                    headers: { 'Content-Type': 'application/json' }
                });

                clearTimeout(timeoutId);
                if (!response.ok) throw new Error(`HTTP Error: ${response.status}`);

                const data = await response.json();
                const scores = Array.isArray(data.scores) ? data.scores : [];

                await processScoreData(scores, {
                    remainingRaces: data.remainingRaces,
                    showRemainingRaces: data.showRemainingRaces !== false,
                    isOverallUpdate: data.isOverallUpdate === true
                });

            } catch (error) {
                console.error('更新エラー:', error);
                const container = document.getElementById('scores-container');
                if (container) container.innerHTML = '<div class="no-data">スコア取得エラー</div>';
            } finally {
                isUpdateBusy = false;
            }
        }

        // 共通スコア処理ロジック（アニメーション制御含む）
        async function processScoreData(scores, options = {}) {
            const container = document.getElementById('scores-container');
            if (!container) return;

            // オプションのデフォルト値設定
            const remainingRaces = options.remainingRaces;
            const showRemainingRaces = options.showRemainingRaces !== false; // default true
            const isOverallUpdate = options.isOverallUpdate === true; // default false

            // スコアでソート（降順）
            scores.sort((a, b) => (b.score || 0) - (a.score || 0));

            if (scores.length === 0) {
                container.innerHTML = '<div class="no-data">スコアデータがありません</div>';
                // 残りレース数表示を隠す
                const remainingRacesEl = document.getElementById('remaining-races-container');
                if (remainingRacesEl) remainingRacesEl.style.display = 'none';

                previousScores.clear();
                countUpAnimations.forEach(id => clearInterval(id));
                countUpAnimations.clear();
                // データが空になった場合、次のデータ取得を「初回ロード」として扱うためにフラグをリセット
                hasDataEverLoaded = false;
                isFirstLoad = true;
                previousTeamOrder = [];
                return;
            }

            // チーム順序とステータス
            const currentTeamOrder = scores.map(team => team.team || team.name || '');
            const hasRankingChanged = hasDataEverLoaded && previousTeamOrder.length > 0 &&
                !currentTeamOrder.every((team, index) => team === previousTeamOrder[index]);

            const needsCountUp = scores.some(team => {
                const teamName = team.team || team.name || '';
                const prevScore = previousScores.get(teamName);
                return prevScore !== undefined && prevScore !== (team.score || 0);
            });

            // 自チームの自動選択
            const currentPlayerTeam = scores.find(team => team.isCurrentPlayer);
            if (currentPlayerTeam && (!selectedTeamInfo || selectedTeamInfo.name !== (currentPlayerTeam.team || currentPlayerTeam.name))) {
                selectedTeamInfo = { name: (currentPlayerTeam.team || currentPlayerTeam.name) };
            }

            // レース数表示の更新
            if (remainingRaces !== undefined) {
                updateRemainingRaces(remainingRaces, showRemainingRaces);
                previousRemainingRaces = remainingRaces;
                lastShowRemainingRaces = showRemainingRaces;
            } else if (previousRemainingRaces !== null) {
                // If not provided (e.g. preview), use previous
                updateRemainingRaces(previousRemainingRaces, lastShowRemainingRaces);
            }

            // フェード効果（合計点計測時など）
            const shouldFadeIn = !hasDataEverLoaded || isOverallUpdate;
            if (hasDataEverLoaded && shouldFadeIn) {
                container.classList.add('overlay-fade-out');
                await new Promise(resolve => setTimeout(resolve, 500));
                container.classList.remove('overlay-fade-out');
            }

            // --- 演出シーケンスの実行 ---
            if (window.animSettings && !window.animSettings.rankAnim) {
                // アニメーション無効時は即座に描画
                renderScoreList(scores, container, false);
            } else if (hasRankingChanged) {
                // 順位変動がある場合（並列アニメーション実行）
                const preAnimationScores = new Map();
                scores.forEach(team => {
                    const teamName = team.team || team.name || '';
                    const prevScore = previousScores.get(teamName);
                    if (prevScore !== undefined) preAnimationScores.set(teamName, prevScore);
                });

                // 演出開始前に状態を更新して後続の重複検知を防止
                previousTeamOrder = [...currentTeamOrder];

                await animateRankingChange(currentTeamOrder, scores, container, preAnimationScores);
            } else if (needsCountUp) {
                // 順位変動がないがスコアが加算された場合
                renderScoreList(scores, container, true); // 前回の値で描画

                const countUpPromises = [];
                scores.forEach(team => {
                    const teamName = team.team || team.name || '';
                    const prevScore = previousScores.get(teamName);
                    const currentScore = team.score || 0;

                    if (prevScore !== undefined && prevScore !== currentScore) {
                        const scoreBox = document.querySelector(`[data-team="${escapeHtml(teamName)}"]`);
                        if (scoreBox) {
                            if (team.addedScore > 0 && (!window.animSettings || window.animSettings.flash)) {
                                scoreBox.classList.remove('score-flash-active');
                                void scoreBox.offsetWidth; // Trigger reflow to restart animation
                                scoreBox.classList.add('score-flash-active');

                                scoreBox.addEventListener('animationend', () => {
                                    scoreBox.classList.remove('score-flash-active');
                                }, { once: true });
                            }
                            countUpPromises.push(animateCountUp(scoreBox, prevScore, currentScore, 1000));
                        }
                    }
                });
                await Promise.all(countUpPromises);
                renderScoreList(scores, container, false); // 最終同期
            } else {
                // 通常の定期更新
                renderScoreList(scores, container, false);
            }

            // フェードイン完了
            // 初回ロード時は行ごとのスライドアニメーション（slide-in-initial）があるため、
            // コンテナ全体のフェードイン（overlay-fade-in）は適用しない（競合回避）。
            if (shouldFadeIn && !isFirstLoad) {
                container.classList.add('overlay-fade-in');
                setTimeout(() => container.classList.remove('overlay-fade-in'), 800);
            }

            // 状態更新
            previousTeamOrder = [...currentTeamOrder];
            scores.forEach(team => {
                const teamName = team.team || team.name || '';
                previousScores.set(teamName, team.score || 0);
            });
            hasDataEverLoaded = true;

            hasDataEverLoaded = true;

            // 補助的な演出（加算点数フロートなど）
            // アニメーションが完了した後に実行されるようにする
            // triggerAddedScoreEffects は await animateRankingChange または await Promise.all(countUpPromises) の後で行うべきだが、
            // 上記のif分岐ですでに await されているため、ここでの呼び出しは適切なタイミングになる。
            // ユーザーフィードバックに基づき、アニメーション終了後に少し間（マージン）を空けてから実行する。
            setTimeout(() => {
                requestAnimationFrame(() => {
                    triggerAddedScoreEffects(scores);
                });
            }, 500);

            if (isFirstLoad) {
                // プレビューモードでは初期ロード時のスライドインアニメーションを無効化（ごちゃつき防止）
                if (!isPreviewMode) {
                    const teamRows = document.querySelectorAll('[data-team-row]');
                    teamRows.forEach((el, i) => {
                        el.classList.add('slide-in-initial');
                        el.style.animationDelay = `${i * 0.05}s`;
                    });
                }
                isFirstLoad = false;
            }
        }

        // 加算点数フロート演出の実行
        function triggerAddedScoreEffects(scores) {
            scores.forEach(team => {
                const teamName = team.team || team.name || '';
                const currentScore = team.score || 0;
                const lastAnimatedScore = lastAnimatedTotalScores.get(teamName);

                // 初回読み込み時、またはスコアが同じ場合はアニメーションさせない
                if (lastAnimatedScore === undefined) {
                    lastAnimatedTotalScores.set(teamName, currentScore);
                    return;
                }

                if (team.addedScore && team.addedScore > 0 && currentScore > lastAnimatedScore) {
                    const addedScoreElement = document.querySelector(`[data-added-score="${escapeHtml(teamName)}"]`);
                    if (addedScoreElement && !addedScoreElement.classList.contains('added-score-float')) {
                        addedScoreElement.classList.add('added-score-float');
                        lastAnimatedTotalScores.set(teamName, currentScore);
                    }
                } else if (currentScore !== lastAnimatedScore) {
                    // スコアに変化があった場合（加算点表示がない場合も含む）は値を更新
                    lastAnimatedTotalScores.set(teamName, currentScore);
                }
            });
        }

        // スコアリストをレンダリングする関数（カウントアップ対応版・非破壊更新機能付き）
        function renderScoreList(scores, container, useCountUp = false) {
            const isMKW = currentTheme === 'mkw';
            const previousRemainingRacesContainer = document.getElementById('remaining-races-container');
            const previousRemainingRacesDisplay = previousRemainingRacesContainer ? previousRemainingRacesContainer.style.display : 'none';

            // 現在のDOMとの差分チェック（非破壊更新が可能か判定）
            const currentRows = container.querySelectorAll('[data-team-row]');
            const canPatch = currentRows.length === scores.length && Array.from(currentRows).every((row, i) => {
                const teamName = scores[i].team || scores[i].name || '';
                return row.getAttribute('data-team-row') === teamName;
            });

            if (canPatch) {
                // DOM構造が一致するため、要素を破棄せず中身だけ更新する（アニメーション維持のため）
                scores.forEach((team, index) => {
                    const row = currentRows[index];
                    const teamName = team.team || team.name || '';
                    const isCurrentPlayer = team.isCurrentPlayer === true;
                    const isTeamSelected = (selectedTeamInfo && selectedTeamInfo.name === teamName);
                    const isEffectivelyCurrent = isCurrentPlayer || isTeamSelected;

                    // ボーダークラスの計算
                    let targetBorderClass = 'static-parallelogram-border';
                    if (isEffectivelyCurrent) {
                        if (isMKW) {
                            targetBorderClass = 'mkw-parallelogram mkw-parallelogram-active';
                        } else {
                            const style = (window.overlayConfig?.overlayColors?.ownTeamStyle || 'rainbow');
                            if (style === 'rainbow') targetBorderClass = 'rainbow-border';
                            else if (style === 'solid') targetBorderClass = 'animated-parallelogram-border';
                            else if (style === 'gradient') {
                                const grad = window.overlayConfig?.overlayColors?.ownTeamGradient || 'blue';
                                targetBorderClass = `gradient-${grad}-border`;
                            } else targetBorderClass = 'rainbow-border';
                        }
                    } else {
                        targetBorderClass = isMKW ? 'mkw-parallelogram' : 'static-parallelogram-border';
                    }

                    // チーム名コンテナのボーダー更新
                    const nameContainer = row.firstElementChild;
                    updateBorderClass(nameContainer, targetBorderClass);

                    // チーム名テキストスタイルの更新
                    const nameText = nameContainer.querySelector('span');
                    if (nameText) {
                        if (isMKW && isEffectivelyCurrent) {
                            nameText.className = `text-center font-bold text-yellow-400 whitespace-nowrap px-0.5`;
                        } else {
                            nameText.className = `text-center font-medium text-white whitespace-nowrap px-0.5`;
                        }
                    }

                    // スコアボックスの更新
                    const scoreContainer = row.children[1];
                    const scoreBox = scoreContainer.children[0];
                    updateBorderClass(scoreBox, targetBorderClass);

                    const scoreText = scoreBox.querySelector('span'); // 最初のspanがスコア
                    const myTeam = scores.find(s => s.isCurrentPlayer === true) ||
                        (selectedTeamInfo ? scores.find(s => (s.team || s.name) === selectedTeamInfo.name) : null);

                    // スコア値の更新（カウントアップ中でない場合のみ）
                    if (!useCountUp || !previousScores.has(teamName) || previousScores.get(teamName) === (team.score || 0)) {
                        if (scoreText) scoreText.textContent = team.score || 0;
                    }

                    if (scoreText) {
                        scoreText.className = `${isMKW ? 'mkw-score-text text-lg' : 'text-base font-medium'} text-center ${isMKW && isEffectivelyCurrent ? 'text-yellow-400' : 'text-white'}`;
                    }

                    // 加算点加算エフェクトの更新
                    let addedScoreSpan = scoreBox.querySelector('[data-added-score]');
                    if (team.addedScore && team.addedScore > 0) {
                        if (!addedScoreSpan) {
                            addedScoreSpan = document.createElement('span');
                            addedScoreSpan.setAttribute('data-added-score', teamName);
                            addedScoreSpan.className = `absolute right-1 top-0 text-green-400 font-bold text-xs ${isMKW ? 'mkw-font' : ''}`;
                            scoreBox.children[0].appendChild(addedScoreSpan); // relative z-20 container
                        }
                        addedScoreSpan.textContent = `+${team.addedScore}`;
                    } else if (addedScoreSpan) {
                        addedScoreSpan.remove();
                    }

                    // 差分表示の更新
                    let diffDisplayHtml = '';
                    if (myTeam) {
                        if (teamName !== (myTeam.team || myTeam.name)) {
                            const scoreDiff = myTeam.score - team.score;
                            const diffText = scoreDiff === 0 ? "0" : scoreDiff > 0 ? `+${scoreDiff}` : `${scoreDiff}`;
                            const textColor = scoreDiff > 0 ? 'text-green-400' : scoreDiff < 0 ? 'text-red-400' : 'text-white';
                            const iconColor = scoreDiff > 0 ? 'text-green-400' : scoreDiff < 0 ? 'text-red-400' : 'text-blue-300';
                            diffDisplayHtml = `
                                <div class="relative ${targetBorderClass} overflow-visible">
                                    <div class="flex items-center gap-1 px-1.5 py-0.5 text-sm font-bold ${textColor} relative z-10">
                                        <svg class="h-3 w-3 ${iconColor}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"/>
                                        </svg>
                                        <span class="${isMKW ? 'mkw-font' : ''}">${diffText}</span>
                                    </div>
                                </div>`;
                        }
                    } else if (index < scores.length - 1) {
                        // Default ranking diff logic
                        const scoreDiff = scores[index].score - scores[index + 1].score;
                        const diffText = scoreDiff > 0 ? `+${scoreDiff}` : `${scoreDiff}`;
                        diffDisplayHtml = `
                            <div class="relative ${targetBorderClass} overflow-visible">
                                <div class="flex items-center gap-1 px-1.5 py-0.5 text-sm font-bold text-white relative z-10">
                                    <svg class="h-3 w-3 text-blue-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"/>
                                    </svg>
                                    <span class="${isMKW ? 'mkw-font' : ''}">${diffText}</span>
                                </div>
                            </div>`;
                    }

                    // 差分要素の更新（HTML書き換えで対応）
                    // 差分要素はアニメーションを持たない（ボーダーもstatic）のでinnerHTML置換でOK
                    // ただし自分自身のボーダーアニメーションがあるため、borderClassは維持する必要がある
                    // → 差分表示自体がdivで囲まれているため、scoreContainerの2番目の子要素（存在すれば）を書き換える

                    // scoreContainer.children[1] is the diff element if it exists
                    const existingDiff = scoreContainer.children.length > 1 ? scoreContainer.children[1] : null;
                    if (diffDisplayHtml) {
                        if (existingDiff) {
                            existingDiff.outerHTML = diffDisplayHtml; // Replace entirely
                        } else {
                            scoreContainer.insertAdjacentHTML('beforeend', diffDisplayHtml);
                        }
                    } else if (existingDiff) {
                        existingDiff.remove();
                    }

                });

                // 残りレース数表示の更新（DOMが維持されているので再取得不要かもしれないが、安全のため）
                updateRemainingRaces(previousRemainingRaces, lastShowRemainingRaces);
                return;
            }

            // --- フォールバック：通常描画（初回ロードや順位変動時） ---

            container.innerHTML = `
                <div class="space-y-0 w-full max-w-md mx-auto relative ${isMKW ? 'theme-mkw' : ''}">
                    <!-- 残りレース数表示（1位チームの左側に独立配置） -->
                    <div id="remaining-races-container" class="absolute left-0 top-0 z-10" style="display: none; transform: translateX(-70px);">
                        <!-- 動的に内容が挿入される -->
                    </div>
                    
                    ${scores.map((team, index) => {
                const teamName = team.team || team.name || '';
                const isCurrentPlayer = team.isCurrentPlayer === true;
                const isFirstPlace = index === 0;
                const isTeamSelected = (selectedTeamInfo && selectedTeamInfo.name === teamName);
                const isEffectivelyCurrent = isCurrentPlayer || isTeamSelected;

                // ボーダークラスの決定
                let borderClass = 'static-parallelogram-border';
                if (isEffectivelyCurrent) {
                    if (isMKW) {
                        borderClass = 'mkw-parallelogram mkw-parallelogram-active';
                    } else {
                        // デフォルトテーマのカスタムスタイル
                        const style = (window.overlayConfig?.overlayColors?.ownTeamStyle || 'rainbow');
                        if (style === 'rainbow') {
                            borderClass = 'rainbow-border';
                        } else if (style === 'solid') {
                            borderClass = 'animated-parallelogram-border';
                        } else if (style === 'gradient') {
                            const grad = window.overlayConfig?.overlayColors?.ownTeamGradient || 'blue';
                            borderClass = `gradient-${grad}-border`;
                        } else {
                            borderClass = 'rainbow-border';
                        }
                    }
                } else {
                    if (isMKW) {
                        borderClass = 'mkw-parallelogram';
                    } else {
                        borderClass = 'static-parallelogram-border';
                    }
                }

                // 自チームを探す
                const myTeam = scores.find(s => s.isCurrentPlayer === true) ||
                    (selectedTeamInfo ? scores.find(s => (s.team || s.name) === selectedTeamInfo.name) : null);

                // カウントアップ値を決定
                let displayScore = team.score || 0;
                if (useCountUp && previousScores.has(teamName)) {
                    const prevScore = previousScores.get(teamName);
                    if (prevScore !== displayScore) {
                        displayScore = prevScore;
                    }
                }

                // 差分計算
                let diffDisplay = '';
                if (myTeam) {
                    if (teamName !== (myTeam.team || myTeam.name)) {
                        const scoreDiff = myTeam.score - team.score;
                        const diffText = scoreDiff === 0 ? "0" : scoreDiff > 0 ? `+${scoreDiff}` : `${scoreDiff}`;
                        const textColor = scoreDiff > 0 ? 'text-green-400' : scoreDiff < 0 ? 'text-red-400' : 'text-white';
                        const iconColor = scoreDiff > 0 ? 'text-green-400' : scoreDiff < 0 ? 'text-red-400' : 'text-blue-300';
                        diffDisplay = `
                                    <div class="relative ${borderClass} overflow-visible">
                                        <div class="flex items-center gap-1 px-1.5 py-0.5 text-sm font-bold ${textColor} relative z-10">
                                            <svg class="h-3 w-3 ${iconColor}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"/>
                                            </svg>
                                            <span class="${isMKW ? 'mkw-font' : ''}">${diffText}</span>
                                        </div>
                                    </div>
                                `;
                    }
                } else if (index < scores.length - 1) {
                    const scoreDiff = scores[index].score - scores[index + 1].score;
                    const diffText = scoreDiff > 0 ? `+${scoreDiff}` : `${scoreDiff}`;
                    diffDisplay = `
                                <div class="relative ${borderClass} overflow-visible">
                                    <div class="flex items-center gap-1 px-1.5 py-0.5 text-sm font-bold text-white relative z-10">
                                        <svg class="h-3 w-3 text-blue-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"/>
                                        </svg>
                                        <span class="${isMKW ? 'mkw-font' : ''}">${diffText}</span>
                                    </div>
                                </div>
                            `;
                }

                return `
                            <div class="${isMKW ? 'h-9' : 'h-12'} flex items-center gap-1 px-2 border-0 rounded-lg transition-all duration-200 cursor-pointer relative"
                                 ondblclick="toggleTeamSelection('${escapeHtml(teamName)}')"
                                 data-team-row="${escapeHtml(teamName)}">
                                
                                <!-- チーム名 -->
                                <div class="relative w-20 h-7 ${borderClass} overflow-visible">
                                    <div class="relative z-20 w-full h-full flex items-center justify-center">
                                        <span class="text-center ${isMKW && isEffectivelyCurrent ? 'font-bold text-yellow-400' : 'font-medium text-white'} whitespace-nowrap px-0.5" style="font-size: ${teamName.length <= 3 ? '0.75rem' : '0.6rem'}">
                                            ${escapeHtml(teamName)}
                                        </span>
                                    </div>
                                </div>
                                
                                <!-- スコアと差分表示のグループ -->
                                <div class="flex items-center gap-0.5">
                                    <!-- スコア -->
                                    <div class="relative w-16 h-7 score-box ${borderClass} overflow-visible" data-team="${escapeHtml(teamName)}">
                                        <div class="relative z-20 w-full h-full flex items-center justify-center">
                                            <span class="${isMKW ? 'mkw-score-text text-lg' : 'text-base font-medium'} text-center ${isMKW && isEffectivelyCurrent ? 'text-yellow-400' : 'text-white'}">
                                                ${displayScore}
                                            </span>
                                            <!-- 加算点数表示（スコア枠内の右側） -->
                                            ${team.addedScore && team.addedScore > 0 ? `
                                                <span class="absolute right-1 top-0 text-green-400 font-bold text-xs ${isMKW ? 'mkw-font' : ''}" data-added-score="${escapeHtml(teamName)}">
                                                    +${team.addedScore}
                                                </span>
                                            ` : ''}
                                        </div>
                                    </div>
                                    
                                    <!-- 差分スコア表示（スコア枠に隣接） -->
                                    ${diffDisplay}
                                </div>
                                
                                <!-- 右端のスペーサー -->
                                <div class="flex-1"></div>
                            </div>
                        `;
            }).join('')}
                </div>
            `;

            // 再描画時に残りレース数を復元
            updateRemainingRaces(previousRemainingRaces, lastShowRemainingRaces);
        }

        // ボーダークラスを安全に更新するヘルパー関数
        function updateBorderClass(element, targetClass) {
            // 現在のボーダークラスをすべて削除
            const allBorderClasses = [
                'static-parallelogram-border',
                'animated-parallelogram-border',
                'rainbow-border',
                'mkw-parallelogram',
                'mkw-parallelogram-active',
                'gradient-blue-border',
                'gradient-pink-border',
                'gradient-orange-border',
                'gradient-emerald-border'
            ];

            // クラスリストの変更が必要かチェック（不必要なDOM操作を避ける）
            const currentClasses = Array.from(element.classList);
            const hasTarget = currentClasses.includes(targetClass.split(' ')[0]); // 簡易チェック

            // 含まれていない、または余計なクラスが含まれている場合は更新
            // 厳密には "rainbow-border" があって "static..." もある変な状態を防ぐためリセット推奨

            element.classList.remove(...allBorderClasses);

            // 新しいクラスを追加（複数クラス対応）
            const newClasses = targetClass.split(' ');
            element.classList.add(...newClasses);
        }

        // 順位変動アニメーション（テーマに応じた演出順序制御）
        async function animateRankingChange(newOrder, scores, container, preAnimationScores = null) {
            const currentElements = container.querySelectorAll('[data-team-row]');
            if (currentElements.length === 0) {
                renderScoreList(scores, container, false);
                return;
            }

            const elementMap = new Map();
            const elementPositions = new Map();
            const isMKW = currentTheme === 'mkw';

            // 実際の要素の高さから計算
            const firstEl = currentElements[0].getBoundingClientRect();
            const secondEl = currentElements[1] ? currentElements[1].getBoundingClientRect() : null;
            const rowHeight = secondEl ? (secondEl.top - firstEl.top) : firstEl.height;

            currentElements.forEach((element, index) => {
                const teamName = element.getAttribute('data-team-row');
                elementMap.set(teamName, element);
                elementPositions.set(teamName, index * rowHeight);
            });

            const newPositions = new Map();
            newOrder.forEach((teamName, index) => {
                newPositions.set(teamName, index * rowHeight);
            });

            // 1. スライドアニメーションの準備
            const slidePromises = [];
            elementMap.forEach((element, teamName) => {
                const currentPos = elementPositions.get(teamName);
                const newPos = newPositions.get(teamName);

                if (currentPos !== undefined && newPos !== undefined && Math.abs(currentPos - newPos) > 1) {
                    const deltaY = newPos - currentPos;
                    element.style.setProperty('--start-y', '0px');
                    element.style.setProperty('--end-y', `${deltaY}px`);
                    element.classList.add('position-slide', 'sliding-element');

                    slidePromises.push(new Promise(resolve => {
                        element.addEventListener('animationend', () => {
                            element.style.transform = `translateY(${deltaY}px)`;
                            element.classList.remove('position-slide');
                            resolve();
                        }, { once: true });
                    }));
                }
            });

            const countUpAnimations = [];
            const triggerCountUp = () => {
                if (!preAnimationScores) return;
                scores.forEach(team => {
                    const teamName = team.team || team.name || '';
                    const prevScore = preAnimationScores.get(teamName);
                    const currentScore = team.score || 0;

                    if (prevScore !== undefined && prevScore !== currentScore) {
                        const rowElement = elementMap.get(teamName);
                        if (rowElement) {
                            const scoreBox = rowElement.querySelector(`[data-team="${escapeHtml(teamName)}"]`);
                            if (scoreBox) {
                                if (team.addedScore > 0) {
                                    // フラッシュエフェクト（背景の発光）は、スライドと同時だと目立ちすぎるため
                                    // あえて少しだけ遅らせて開始します（カウントアップ自体は即座に並列で走ります）
                                    setTimeout(() => {
                                        if (scoreBox) scoreBox.classList.add('score-flash-active');
                                    }, 150);
                                    setTimeout(() => {
                                        if (scoreBox) scoreBox.classList.remove('score-flash-active');
                                    }, 1350);
                                }
                                countUpAnimations.push(animateCountUp(scoreBox, prevScore, currentScore, 1000));
                            }
                        }
                    }
                });
            };

            // 2. 演出シーケンスの実行
            // 順位変動のスライドと点数のカウントアップを並列で実行
            triggerCountUp();
            await Promise.all([...slidePromises, ...countUpAnimations]);

            // 3. 最終的なDOM構造に並べ替えて再描画
            renderScoreList(scores, container, false);

            elementMap.forEach((element) => {
                element.style.removeProperty('transform');
                element.classList.remove('sliding-element');
            });
        }

        // HTMLエスケープ関数
        function escapeHtml(text) {
            if (text === undefined || text === null) return '';
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return String(text).replace(/[&<>"']/g, function (m) { return map[m]; });
        }

        let previousScores = new Map(); // 前回のスコアを保存
        let isFirstLoad = true; // 初回読み込みフラグ
        let countUpAnimations = new Map(); // 進行中のカウントアップアニメーションを管理

        // カウントアップアニメーション関数
        function animateCountUp(element, startValue, endValue, duration = 1000) {
            return new Promise((resolve) => {
                const teamName = element.getAttribute('data-team');

                // 既存のアニメーションがあれば停止
                if (countUpAnimations.has(teamName)) {
                    clearInterval(countUpAnimations.get(teamName));
                }

                const startTime = Date.now();
                const difference = endValue - startValue;

                // スコア要素内のテキスト要素を取得
                const isMKW = currentTheme === 'mkw';
                const scoreTextElement = element.querySelector('span');

                if (!scoreTextElement) {
                    resolve();
                    return;
                }

                // カウントアップ中の視覚効果を追加
                element.classList.add('score-counting-up');
                scoreTextElement.classList.add('counting-text');

                const updateScore = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // イージング関数（accelerated deceleration）
                    const easeOutQuad = 1 - Math.pow(1 - progress, 2);
                    const currentValue = Math.floor(startValue + (difference * easeOutQuad));

                    // スコア要素内のテキストを更新
                    scoreTextElement.textContent = currentValue;

                    if (progress >= 1) {
                        // アニメーション完了
                        scoreTextElement.textContent = endValue;

                        // 視覚効果を削除
                        element.classList.remove('score-counting-up');
                        scoreTextElement.classList.remove('counting-text');

                        countUpAnimations.delete(teamName);
                        console.log(`Count-up animation completed for ${teamName}: ${startValue} → ${endValue}`);
                        resolve();
                    }
                };

                // アニメーションを開始
                const intervalId = setInterval(updateScore, 16); // 約60fps
                countUpAnimations.set(teamName, intervalId);

                // 完了時の処理（フェイルセーフ）
                setTimeout(() => {
                    clearInterval(intervalId);
                    countUpAnimations.delete(teamName);

                    // 最終値を設定
                    scoreTextElement.textContent = endValue;

                    // 視覚効果を削除
                    element.classList.remove('score-counting-up');
                    scoreTextElement.classList.remove('counting-text');

                    resolve();
                }, duration + 100); // 少し余裕を持たせる
            });
        }

        // --- 資産のプリロードと初期化の最適化 ---
        async function initialize() {
            console.log('Initializing overlay assets...');

            // 背景画像のプリロード
            const preloadImg = new Image();
            preloadImg.src = '/overlay/background.png';

            // フォントのロード待機
            try {
                if (document.fonts) {
                    await document.fonts.ready;
                    console.log('Fonts loaded');
                }
            } catch (e) {
                console.warn('Font loading check failed, proceeding anyway');
            }

            // 画像のデコード待機（カクつき防止）
            try {
                if (preloadImg.decode) await preloadImg.decode();
            } catch (e) { }

            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('preview') === 'true') {
                console.log('Preview mode detected. Skipping initial data fetch.');
                return;
            }

            console.log('Assets ready, starting score update');
            updateScores();
        }

        // 起動！
        initialize();

        // SSE接続でリアルタイム更新（堅牢性強化版）
        let sseReconnectAttempts = 0;
        const MAX_SSE_RECONNECT_ATTEMPTS = 10;
        const BASE_RECONNECT_DELAY = 1000; // 1秒
        let currentEventSource = null;

        function setupSSE() {
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('preview') === 'true') {
                console.log('Preview mode detected. Skipping SSE setup.');
                return;
            }

            // 既存の接続をクリーンアップ
            if (currentEventSource) {
                currentEventSource.close();
                currentEventSource = null;
            }

            console.log(`SSE接続試行 (${sseReconnectAttempts + 1}/${MAX_SSE_RECONNECT_ATTEMPTS})`);

            try {
                currentEventSource = new EventSource('/api/scores/events');

                currentEventSource.onopen = function (event) {
                    console.log('SSE接続が正常に確立されました');
                    sseReconnectAttempts = 0; // 成功時はカウンターをリセット
                };

                currentEventSource.onmessage = function (event) {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'scores-updated') {
                            console.log('Received score update notification');
                            updateScores();
                        } else if (data.type === 'config-updated') {
                            console.log('Received config update notification');
                            updateTheme();
                        } else if (data.type === 'connected') {
                            console.log('SSE接続確立通知を受信、強制同期します');
                            updateScores();
                            updateTheme();
                        }
                    } catch (error) {
                        console.error('SSE message parsing error:', error);
                    }
                };

                currentEventSource.onerror = function (error) {
                    console.error('SSE connection error:', error);

                    // 現在の接続を閉じる
                    if (currentEventSource) {
                        currentEventSource.close();
                        currentEventSource = null;
                    }

                    // 最大再試行回数に達した場合は停止
                    if (sseReconnectAttempts >= MAX_SSE_RECONNECT_ATTEMPTS) {
                        console.error('SSE再接続の最大試行回数に達しました。手動でページを更新してください。');
                        return;
                    }

                    // 指数バックオフで再接続を試行
                    const delay = BASE_RECONNECT_DELAY * Math.pow(2, sseReconnectAttempts);
                    const maxDelay = 30000; // 最大30秒
                    const actualDelay = Math.min(delay, maxDelay);

                    console.log(`${actualDelay / 1000}秒後にSSE再接続を試行します...`);
                    sseReconnectAttempts++;

                    setTimeout(() => {
                        setupSSE();
                    }, actualDelay);
                };

            } catch (error) {
                console.error('SSE接続の初期化に失敗:', error);

                // 初期化エラーの場合も再試行
                if (sseReconnectAttempts < MAX_SSE_RECONNECT_ATTEMPTS) {
                    sseReconnectAttempts++;
                    setTimeout(() => {
                        setupSSE();
                    }, BASE_RECONNECT_DELAY);
                }
            }
        }

        // ページがアンロードされる前にSSE接続をクリーンアップ
        window.addEventListener('beforeunload', function () {
            if (currentEventSource) {
                currentEventSource.close();
                currentEventSource = null;
            }
        });

        // SSE接続を開始
        setupSSE();
    </script>
</body>

</html>